//EZgpsmethods for adding simple preconfigured gps magic -Jonathan

//----------------------------------------------------------------Configuration Hex------------------------------------------------------------------------------------
// This section contains the preconfigured arrays of hex to change GPS configurations. Could be partially calculated in advance, but no need

//-----------------------------------------Disable Unused Messages---(UBX-CFG-MSG)----------------------------------
void gps_nuke_messages(){

    const char nuke_msg[] PROGMEM = {
        0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xF0, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, //RMC
        0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xF0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2A, //GLL
        0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xF0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x31, //GSA
        0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xF0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x38, //GSV
        0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xF0, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x46 //VTG
    };
  
    gps_write(nuke_msg,sizeof(nuke_msg));
}

void gps_set_GGA(){
  
    const char gga_msg[] PROGMEM = {
      0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xF0, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28
    };
  
    gps_write(gga_msg,sizeof(gga_msg));
}

//-------------------------------------------UpdateHz----- (UBX-CFG-RATE)-------------------------------------------

void set_gps_one_hertz(){
    const char one_hertz[] PROGMEM = {0xB5, 0x62, 0x06, 0x08 ,0x06 ,0x00 ,0xE8 ,0x03 ,0x01 ,0x00 ,0x01 ,0x00 ,0x01 ,0x39};
  
    gps_write(one_hertz,sizeof(one_hertz));
}

void set_gps_five_hertz(){
    const char five_hertz[] PROGMEM = {0xB5 ,0x62 ,0x06 ,0x08 ,0x06 ,0x00 ,0xC8 ,0x00 ,0x01 ,0x00 ,0x01 ,0x00 ,0xDE ,0x6A};
  
    gps_write(five_hertz,sizeof(five_hertz));
}

void set_gps_ten_hertz(){
    const char ten_hertz[] PROGMEM = {0xB5 ,0x62 ,0x06 ,0x08 ,0x06 ,0x00 ,0x64 ,0x00 ,0x01 ,0x00 ,0x01 ,0x00 ,0x7A ,0x12};
  
    gps_write(ten_hertz,sizeof(ten_hertz));
}

//-----------------------------------------------Baud----(UBX-CFG-PRT)---------------------------------------------

void gps_set_baud_default(){ //9600

    const char defaultBaud[] PROGMEM = {
        0xB5,0x62,0x06,0x00,0x14,0x00,0x01,0x00,0x00,0x00,0xD0,0x08,0x00,0x00,
        0x80,0x25,0x00,0x00,0x07,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0xA2,0xB5
    };
    gps_write(defaultBaud,sizeof(defaultBaud));
}

void gps_set_baud_fast(){ //115200
  
    const char quickBaud[] PROGMEM = {
        0xB5,0x62,0x06,0x00,0x14,0x00,0x01,0x00 ,0x00 ,0x00,0xD0,0x08,0x00,0x00,
        0x00,0xC2,0x01,0x00,0x07,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0xC0,0x7E
    };
    gps_write(quickBaud,sizeof(quickBaud));
}

void gps_set_baud_ultra(){
  
    const char ultraBaud[] PROGMEM = { //921600
        0xB5,0x62,0x06,0x00,0x14,0x00,0x01,0x00,0x00,0x00,0xD0,0x08,0x00,0x00,
        0x00,0x10,0x0E,0x00,0x07,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x1B,0x5A
    };
    gps_write(ultraBaud,sizeof(ultraBaud));
}

//-------------------------------------------------Nav Mode---- (UBX-CFG-NAV5)----------------------------------------

// This mode allows the GPS to work above 12km, so it is critical that this works. First the command is sent, then the
// GPS is polled by sending the navmode_poll characters. If the polling is good, then continue.
//
// TODO: Figure out how the heck this actually works

bool gps_set_navmode_one_g(){
  
    const char navmode_one_g[] PROGMEM = {
        0xB5, 0x62, 0x06, 0x24, 0x24, 0x00, 0xFF, 0xFF, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x05, 0x00, 0xFA, 0x00, 0xFA, 0x00, 
        0x64, 0x00, 0x2C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0xDC
    };
  
    const char navmode_poll[] PROGMEM = {0xB5, 0x62, 0x06, 0x24, 0x00, 0x00, 0x2A, 0x84};
    
    gps_write(navmode_one_g,sizeof(navmode_one_g));
  
    delay(1000);
    
    unsigned int stop_time = millis() + 5000;
    gps_write(navmode_poll,sizeof(navmode_poll));
  
    //---------------Parse UBX return ---------------
    bool rec_ubx_first = false;
    bool rec_ubx = false;
    int ubx_index = 2;
  
    //Sit in a loop until either a UBX packet is parsed or until a timeout is hit
    while(stop_time > millis()){
        if(gpsserial.available()){
          
            int parsed_char = gpsserial.read();
            
            if(rec_ubx){
                if(parsed_char == pgm_read_byte(navmode_one_g+ubx_index)){
                    ubx_index++;
                    if(ubx_index > 43){
                        return true;
                    }
                }else{
                    return false;
                }
            }
            
            if(parsed_char == 181){
                rec_ubx_first = true;
            }else if(parsed_char == 98 && rec_ubx_first == true){
                rec_ubx = true;
            }else{
                rec_ubx_first = false;  
            }
  
        }
    }
    return false; // Return after timeout
}

//-------Save------- (UBX-CFG-CFG)
void gps_save_config(){
  const char save_gps_conf[] PROGMEM = {
    0xB5,0x62,0x06,0x09,0x0D,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x1D,0xAB
  };

  gps_write(save_gps_conf,sizeof(save_gps_conf));
}

// ------------------------------------------ Initialize ------------------------------------------
void gps_init(){  

  //init GPS at proper baud
  gps_baud_init();
  
  // nuke uneeded NMEA msgs
  gps_nuke_messages();
  
  // Make sure the GxGGA msg is active
  gps_set_GGA();

  if(!gps_set_navmode_one_g()){
    Serial.println("navmode_conf_fail");
  }else{
    Serial.println("itworked");
  }

  set_gps_one_hertz();

  gps_save_config();
}

void gps_reset(){
  gpsserial.end();
  gps_init();  
}

void gps_baud_init(){
    gpsserial.begin(9600);
    delay(50);
    gps_set_baud_fast();
    gpsserial.end();
    gpsserial.begin(115200);
  delay(100);
  //gps_set_baud_ultra();
  //gpsserial.end();
  //gpsserial.begin(921600);
  
    //delay(100);
}

// Write the GPS hex code to the GPS port
void gps_write(const char* config_string, int char_length){
    //Serial.println(char_length);
    for(int i = 0; i<char_length;i++){
      gpsserial.write(pgm_read_byte(config_string+i));
    }
}

//const char hexList[] PROGMEM = {
//  //RATES
//  //0xB5, 0x62, 0x06, 0x08 ,0x06 ,0x00 ,0xE8 ,0x03 ,0x01 ,0x00 ,0x01 ,0x00 ,0x01 ,0x39, //1Hz
//  //0xB5 ,0x62 ,0x06 ,0x08 ,0x06 ,0x00 ,0xF4 ,0x01 ,0x01 ,0x00 ,0x01 ,0x00 ,0x0B ,0x77, //2Hz
//  //0xB5 ,0x62 ,0x06 ,0x08 ,0x06 ,0x00 ,0xFA ,0x00 ,0x01 ,0x00 ,0x01 ,0x00 ,0x10 ,0x96, //4Hz
//  //0xB5 ,0x62 ,0x06 ,0x08 ,0x06 ,0x00 ,0xC8 ,0x00 ,0x01 ,0x00 ,0x01 ,0x00 ,0xDE ,0x6A, //5Hz // <CHECK> This is correct, maybe not allowed in airborne mode?
//  //0xB5 ,0x62 ,0x06 ,0x08 ,0x06 ,0x00 ,0x64 ,0x00 ,0x01 ,0x00 ,0x01 ,0x00 ,0x7A ,0x12, //10Hz
//  //BAUD
//  //0xB5 ,0x62 ,0x06 ,0x00 ,0x14 ,0x00 ,0x01 ,0x00 ,0x00 ,0x00 ,0xD0 ,0x08 ,0x00 ,0x00 ,0x80 ,0x25 ,0x00 ,0x00 ,0x07 ,0x00 ,0x03 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0xA2 ,0xB5, //9600
//  0xB5 ,0x62 ,0x06 ,0x00 ,0x14 ,0x00 ,0x01 ,0x00 ,0x00 ,0x00 ,0xD0 ,0x08 ,0x00 ,0x00 ,0x00 ,0xC2 ,0x01 ,0x00 ,0x07 ,0x00 ,0x03 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0xC0 ,0x7E, //115200
//  //AIRBORNE 4g
//  //NEW
//  0xB5, 0x62, 0x06, 0x24, 0x24, 0x00, 0xFF, 0xFF, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x05, 0x00, 0xFA, 0x00, 0xFA, 0x00, 0x64, 0x00, 0x2C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4D, 0xDB,
////0xB5 ,0x62 ,0x06 ,0x24 ,0x24 ,0x00 ,0xFF ,0xFF ,0x08 ,0x03 ,0x00 ,0x00 ,0x00 ,0x00 ,0x10 ,0x27 ,0x00 ,0x00 ,0x05 ,0x00 ,0xFA ,0x00 ,0xFA ,0x00 ,0x64 ,0x00 ,0x2C ,0x01 ,0x00 ,0x3C ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x54 ,0x2C,
//  //SAVE
//  0xB5 ,0x62 ,0x06 ,0x09 ,0x0D ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0xFF ,0xFF ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x03 ,0x1D ,0xAB
//};
//
//
//void GPSINIT(){
//  for(int i = 0;i<sizeof(hexList);i++){
//    gpsserial.write(pgm_read_byte(hexList+i));
//    delay(10); // <CHECK> Why the heck did I add this?
//  }
//}


GPSdata getGPS(){
  GPSdata gpsInfo;
  
    float GPSLat, GPSLon;
    int GPSSats;
    long GPSAlt;
    unsigned long date,fix_age,GPSTime;
    gps.f_get_position(&GPSLat, &GPSLon, &fix_age);
    GPSSats = gps.satellites();
    gps.get_datetime(&date, &GPSTime, &fix_age);
    GPSAlt = gps.altitude()/100.;

    gpsInfo.GPSLat = GPSLat;
    gpsInfo.GPSLon = GPSLon;
    gpsInfo.GPSTime = GPSTime/100;
    gpsInfo.GPSSats = GPSSats;
    gpsInfo.GPSAlt = GPSAlt;
  
  return gpsInfo;
}


// DEBUG PRINT METHOD
void output(){
    String gpspacket;
    if(gpsInfo.GPSSats!=-1){
        gpspacket = String(gpsInfo.GPSTime)+","+String(gpsInfo.GPSLat,6) + "," + String(gpsInfo.GPSLon,6)+","+gpsInfo.GPSAlt+","+gpsInfo.GPSSats;
    }else{
        //gpspacket = String(preserve.GPSTime/100)+","+String(preserve.GPSLat,6) + "," + String(preserve.GPSLon,6)+","+preserve.GPSAlt+","+preserve.GPSSats;
        gpspacket = "err" + String(gpsInfo.GPSTime/100)+","+String(gpsInfo.GPSLat,6) + "," + String(gpsInfo.GPSLon,6)+","+gpsInfo.GPSAlt+","+gpsInfo.GPSSats;
    }
    Serial.println(gpspacket);
}

void gpsWaitForLock(){
    int lastSats = -1;
    while((gpsInfo.GPSAlt<=0)||(gpsInfo.GPSAlt>100000)){
        while (gpsserial.available()){
            if (gps.encode(gpsserial.read())){
                gpsInfo = getGPS();
                break;
            }
        }
        if(gpsInfo.GPSSats > lastSats){
            lastSats = gpsInfo.GPSSats;
            snprintf(xbeeSendBuf, xbeeSendBufSize-1 , "Sats: %d", lastSats);
            OutputSerial.println((char*)xbeeSendBuf);
            xbeeSend(GroundSL,xbeeSendBuf);
            //memset(xbeeSendBuf,0,xbeeSendBufSize);
        }
        
    }  
}

